[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Setup",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting started",
    "section": "",
    "text": "Goal\nThe goal of this section is to learn what you need to do to stand up a Shiny application. Don’t worry if you don’t really understand how the framework works, or why it’s designed in a particular way. All we’re tryign to do at this stage is to get something working, and become comfortable with the development pattern.\n\n\nCreate an app\nShiny apps are divided into two parts. The app UI consists of various input and output components, and the server expresses how those inputs and outputs should interact.\nLet’s start by creating a basic shiny app To do this you can call shiny create . in a project folder, or open up apps/basic-app/app.py in the repo. This is the simplest possible Shiny application with one input and one output.\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: horizontal\n#| viewerHeight: 800\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.panel_title(\"Hello Shiny\"),\n    ui.layout_sidebar(\n        ui.panel_sidebar(ui.input_slider(\"n\", \"N\", 0, 100, 20)),\n        ui.panel_main(ui.output_text_verbatim(\"txt\")),\n    ),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        return f\"n*2 is {input.n() * 2}\"\n\n\napp = App(app_ui, server)\n\n\n## file: app-solution.py\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hello Shiny!\"),\n    ui.input_slider(\"n\", \"N\", 0, 100, 20),\n    ui.input_numeric(\"multiplier\", \"Multipler\", min=0, max=100, step=1, value=5),\n    ui.output_text_verbatim(\"txt\"),\n    ui.output_text_verbatim(\"divide\"),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        k = input.multiplier()\n        return f\"n*{str(k)} is {input.n() * k}\"\n\n    @output\n    @render.text\n    def divide():\n        k = input.multiplier()\n        return f\"n/{str(k)} is {input.n() / k}\"\n\n\napp = App(app_ui, server)\n\nThere are a four important features that your code needs to have to generate a working Shiny app.\n\n1) UI structure\nThe Shiny UI is defined with a set of nested function calls. You typically start with a container function like ui.page_fluid() and then add inputs like ui.input_slider and outputs like ui.output_text_verbatim.\nInputs and outputs have an id value which allows you to refer to their values in the server function. In this simple example the slider id is \"n\" and the output id is \"txt\".\n\n\n3) Output decorators\nThe server function defines how your app should calculate outputs for a given set of inputs. To do this, you write a function inside the main server function which has the same name as the output key, and add two decorators. @output tells Shiny that the function is an output, and @render.text tells it the output type. So to fill in the logic for the txt output we write:\n1@output\n2@render.text\n3def txt():\n    return f\"n*2 is {input.n() * 2}\"\n\n1\n\nIdentify that this function is an output\n\n2\n\nDefine output type\n\n3\n\nFunction name connects it to output id\n\n\n\n\n4) How to refer to inputs\nShiny is a reactive framework which means that it recalculates an output if and only if its inputs change. We’ll learn more about reactivity in the next section, but for now You identify these inputs by calling the attribute of the input object which corresponds with a particular input id. In this case to refer to n we call it with input.n()\n\n\n\n\n\n\nTip\n\n\n\nNote that inputs are called with () so it’s input.n() not input.n\n\n\n\n\n\nExercise\n\nAdd a ui.input_numeric to your UI which identifies the multiplier. Use this to allow people to change the multiplier from the hard coded value of 2 to another number.\nAdd a second ui.output_text_verbatim which calculates the quotient of the two numbers.\n\n\n\nGoalProblemSolution\n\n\n#| standalone: true\n#| components: [viewer]\n#| layout: horizontal\n#| viewerHeight: 800\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hello Shiny!\"),\n    ui.input_slider(\"n\", \"N\", 0, 100, 20),\n    ui.input_numeric(\"multiplier\", \"Multipler\", min=0, max=100, step=1, value=5),\n    ui.output_text_verbatim(\"txt\"),\n    ui.output_text_verbatim(\"divide\"),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        k = input.multiplier()\n        return f\"n*{str(k)} is {input.n() * k}\"\n\n    @output\n    @render.text\n    def divide():\n        k = input.multiplier()\n        return f\"n/{str(k)} is {input.n() / k}\"\n\n\napp = App(app_ui, server)\n\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: horizontal\n#| viewerHeight: 800\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.panel_title(\"Hello Shiny\"),\n    ui.layout_sidebar(\n        ui.panel_sidebar(ui.input_slider(\"n\", \"N\", 0, 100, 20)),\n        ui.panel_main(ui.output_text_verbatim(\"txt\")),\n    ),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        return f\"n*2 is {input.n() * 2}\"\n\n\napp = App(app_ui, server)\n\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: horizontal\n#| viewerHeight: 800\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hello Shiny!\"),\n    ui.input_slider(\"n\", \"N\", 0, 100, 20),\n    ui.input_numeric(\"multiplier\", \"Multipler\", min=0, max=100, step=1, value=5),\n    ui.output_text_verbatim(\"txt\"),\n    ui.output_text_verbatim(\"divide\"),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        k = input.multiplier()\n        return f\"n*{str(k)} is {input.n() * k}\"\n\n    @output\n    @render.text\n    def divide():\n        k = input.multiplier()\n        return f\"n/{str(k)} is {input.n() / k}\"\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\n\nSummary\nIn this section you learned the three main things you need to do to get your Shiny app to run: - Add inputs and outputs to the UI - Add server functions which are decorated with @output and @render - Refer to inputs within server funtions with input.&lt;id&gt;()\nNext we’ll learn what shiny does to make this all work"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Shiny for Python Workshop",
    "section": "",
    "text": "This website contains the materials for the Shiny for Python workshop at the 2023 posit conf."
  },
  {
    "objectID": "index.html#shinylive",
    "href": "index.html#shinylive",
    "title": "Shiny for Python Workshop",
    "section": "1) Shinylive",
    "text": "1) Shinylive\nShinylive allows you to run full featured shiny apps in your browser, and includes a basic editor which is good enough to run examples. As a result you should be able to work through all of the examples in the workshop using just the browser without installing anything locally."
  },
  {
    "objectID": "index.html#locally-with-vs-code",
    "href": "index.html#locally-with-vs-code",
    "title": "Shiny for Python Workshop",
    "section": "2) Locally with VS Code",
    "text": "2) Locally with VS Code\nWhile Shinylive is great, it likely isn’t the environment you’ll use to develop Shiny apps, and so it makes sense to set up VS Code and run the examples locally. To do this follow these steps before the workshop:\n\nInstall VS Code\nInstall the Shiny for Python VS Code extension\nClone the repository with git clone https://github.com/rstudio/shiny-python-workshop-2023.git, or alternately download the repository as a zip file:\n\nNavigate to the project directory and create a new virtual environment with python3 -m venv .vevn\nSet your python interpreter to the virtual environment with CMD + SHIFT + P &gt; Select Interpreter\nOpen a new terminal prompt, which should switch to (.venv)\nInstall the relevant packages with pip install -r requirements.txt\n\nAll of the example apps are stored in the /apps directory. If you’ve installed the VS Code extention can run any of the apps by opening the app.py file and clicking the play button in the top right. Alternately, run them from the command line with shiny run &lt;path-to-app&gt; --reload."
  },
  {
    "objectID": "reactivity.html",
    "href": "reactivity.html",
    "title": "Basic Reactivity",
    "section": "",
    "text": "In the last section we built a very simple shiny app which multiplied two numbers together based on the user’s input. One thing you might notice about the code which genrated this application is that while we specify what should happen in response to a user’s action, we don’t actually specify when it should happen. There are no callbacks in this application which define when a bit of code should re-run, so how does shiny know when to run the code?\nShiny is different from many other frameworks because it is declarative. Instead of specifying when code should run, you specify recipes for creating the output you want to run, and then leave it up to Shiny to figure out when to rerun them. Shiny does this by inferring a reactive computation graph for your application and reredenering downstream elements whenever the upstream elements change.\n\n\n#| standalone: true\n#| components: [editor, viewer]\n#| layout: horizontal\n#| viewerHeight: 800\nfrom shiny import App, render, ui\n\napp_ui = ui.page_fluid(\n    ui.h2(\"Hello Shiny!\"),\n    ui.input_slider(\"n\", \"N\", 0, 100, 20),\n    ui.input_numeric(\"multiplier\", \"Multipler\", min=0, max=100, step=1, value=5),\n    ui.output_text_verbatim(\"txt\"),\n    ui.output_text_verbatim(\"divide\"),\n)\n\n\ndef server(input, output, session):\n    @output\n    @render.text\n    def txt():\n        k = input.multiplier()\n        return f\"n*{str(k)} is {input.n() * k}\"\n\n    @output\n    @render.text\n    def divide():\n        k = input.multiplier()\n        return f\"n/{str(k)} is {input.n() / k}\"\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\n\nflowchart TD\n  N[input.n] --&gt; M((product))\n  K[input.multiplier] --&gt; Q((quotient))\n  N --&gt; Q\n  K --&gt; M"
  }
]